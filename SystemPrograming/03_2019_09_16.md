<h2>부동 소수점</h2>
<p>소수점 정수를 바이너리로 표시하는 방법 가장 기본적인 방법은</br>
		bi bi-1 bi-2...b2 b1 b0 . b-1 b-2 b-3 b-4 .... b-j의 수가 있을 때</br>
		.을 기준으로 왼쪽으로 2의 승수를 0 1 2 3 4 5 하나씩 올려가는 것이고 오른쪽 소수점 너머로는 -1 -2 -3 -4 -5 -1씩 내려간다.</br>
		* Sigma(bk*s^k) k는 -j부터 i까지.</br>
		ex: 5와 3/4 => 101.11(2)</br>
			2와 7/8 = > 10.111(2)</br>
			우측으로 쉬프트하면 2로 나눈 효과를 얻음</br>
			좌측으로 쉬프트하면 2로 곱한 효과를 얻음</br>
	2진 소수를 이용한 숫자의 표현</br>
	0.3으로 2로 계속곱해서 목을 빼서 넣음 그래서 생긴 값이 아래의 1/3값이다</br>
	1/3 => 0.0101010101[01](2)</br>
	1/5 => 0.1100110011[0011](2)</br>			
</p>


<h2>IEEE Floating Point 표준</h2>

<h3>인코딩 방법</h3>
<p><strong>필드의 길이</strong></p>
<ul>
	<li>Single 정밀도(float) -->32비트 : 8 exp 비트, 23 frac 비트</li>
	<li>더블(Double) -->64비트 : 11 exp 비트, 52 frac 비트</li>
	<li>확장(Extended precision) -->80비트 : 15 exp 비트, 63 frac 비트</li>
</ul>
<h3>(-1)^s*M*2^E</h3>
<ul>
	<li>s는 부호 비트: 양/음수 여부를 표시함 0 이면, 양 1이면 음수</li>
	<li>유효숫자 M은 [1.0,2.0) 또는 [0.0,1.0) 사이의 실수 값을 표시</li>
	<li>지수 E는 2의 지수 제곱을 표시</li>
</ul>
<table>
	<thead>
		<tr>
			<th>| s |</th>
			<td>|    exp    |</td>
			<td>|        frac        |</td>
		</tr>
	</thead>
</table>

<ul>
	<li>MSB는 부호 비트</li>
	<li>exp 필드는 E를 인코딩</li>
	<li>frac 필드는 M을 인코딩</li> <- 소수부
</ul>

<h2>정규화된 값(Normalized values)</h2>
<p>조건: exp 필드가 0이 아니고, 전부 1 이 아닌 경우에 즉 0<=exp<=최대값일 경우에 적용</p>
<p>E = exp - bias, exp = E + bias</p>
<ul>
	<li>exp : unsigned value</li>
	<li>bias : 2^(e-1) -1,여기서 e는 지수 비트의 갯수임</li>
	<li>Single precison:127[1111110] (exp 1...254, E -126 ... 127)</li>
	<li>유효 숫자는 묵시적으로 1로 시작하는 것으로 간주함. 0일때 비정규</li>
</ul>
<h3>정규화 값의 인코딩 예제</h3>
<p>float F = 15213.0 =11101101101101(2) = 1.1101101101101 * 2^13</br>
	유효숫자: 23비트</br>
	M = 1.1101101101101(2)</br>
	frac = 110 1101 1011 0100 0000 0000(2) <=23비트</br>
	지수비트: 8비트</br>
	E = 13 						0000 1101(2)</br>
	Bias = 2^(8-1) - 1 = 127	0111 1111(2)</br>
	exp  = E + Bias = 140 = 1000 1100(2) <=8비트</br>
	Floating Point Representation :</br>
	0100 0110(140) _ 0110 1101 1011 0100 0000 0000</br>
	↓↓↓↓↓↓↓↓↓↓</br>
	<strong>1</strong>110 1101 1011 01(2) = 15213</br>
</p>

<h3>비정규화 값의 인코딩</h3>
<p>조건: exp 필드가 전부 0</p>
<p>인코딩</p>
<ul>
	<li>지수: E = 1 - bias</li>
	<li>유효숫자(Signficand value)M = 0.xxx...x2 ==> frac</li>
</ul>
<h3>비정규화 인코딩의 사용</h3>
<p>case 1</p>
<ul>
	<li>exp = 000...0, frac = 000...0</li>
	<li>+0과 -0의 표시의 경우가 다름 부호비트 1 0000000000.. 은 -0 +0은 0 0000000000..</li>
</ul>
<p>case 2: exp = 000...0, frac != 000...0</p>
<ul>
	<li>0.0에 매우 근접한 소수값을 표시(underflow 수의 표시)</li>
	<li>점차적인 언더 플로우 특성 : 0.0 부근의 숫자들이 동일 간격으로 분포 한다.</li>
</ul>
<p>case 3: exp = 1111...1, frac = 000...0</p>
<ul>
	<li>무한대를 표시 (+/-)</li>
	<li>오버 플로우를 표시할 수 있다.</li>
	<li>exp = 1111...1, frac !=0000...0 => NaN :숫자로 표시 할수 없는 결과를 나타낼 때 사용</li>
</ul>

<p>case 3: exp = 1111...1, frac = 000...0</p>
<ul>
	<li>무한대를 표시 (+/-)</li>
	<li>오버 플로우를 표시할 수 있다.</li>
	<li>exp = 1111...1, frac !=0000...0 => NaN :숫자로 표시 할수 없는 결과를 나타낼 때 사용</li>
</ul>
<p>6비트 IEEE 유사한 형식으로 표시하는 경우</p>
<ul>
	<li>무한대를 표시 (+/-)</li>
	<li>오버 플로우를 표시할 수 있다.</li>
	<li>exp = 1111...1, frac !=0000...0 => NaN :숫자로 표시 할수 없는 결과를 나타낼 때 사용</li>
</ul>

















